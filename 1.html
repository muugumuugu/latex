<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spreadsheet-Like LaTeX Editor</title>
<script src="texme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_HTML"></script>
<style>
body { font-family: sans-serif; padding: 20px; }
.container { overflow: auto; max-height: 600px; border: 1px solid #ccc; }
.grid { display: grid; border-collapse: collapse; }
.cell { border: 1px solid #ccc; padding: 4px; min-width: 80px; min-height: 40px; box-sizing: border-box; position: relative; }
.input-cell { width: 100%; height: 100%; border: none; background: #f0f8ff; resize: none; }
.render-cell { background: #fff; width: 100%; height: 100%; overflow: hidden; }
.header { background: #ddd; font-weight: bold; text-align: center; position: sticky; z-index: 2; }
.header.col { top: 0; }
.header.row { left: 0; }
.selected { outline: 2px solid #007bff; }
button { padding: 6px 10px; margin-right: 5px; cursor: pointer; }
</style>
</head>
<body>

<h2>Spreadsheet-Like LaTeX Editor</h2>
<div>
  <button id="addRow">Add Row</button>
  <button id="addCol">Add Column</button>
  <button id="copySelection">Copy Selected</button>
  <button id="exportCSV">Export CSV</button>
</div>
<div class="container">
  <div class="grid" id="grid"></div>
</div>

<script>
window.onload = function() {
  const grid = document.getElementById('grid');
  const columnTypes = []; // 'latex','text','formula'
  const cellMap = {}; // cellId -> {type,value,element,latex?}
  let numRows = 0;
  let numCols = 0;

  // Utilities
  function colName(n){ let s=''; while(n>=0){s=String.fromCharCode(65+n%26)+s;n=Math.floor(n/26)-1;} return s; }
  function rowName(n){ return n+1; }
  function cellId(c,r){ return colName(c)+rowName(r); }

  // Formula evaluation
  function evalFormula(formula){
    if(!formula.startsWith('=')) return formula;
    let expr = formula.slice(1).replace(/([A-Z]+[0-9]+)/g, m => {
      const val = cellMap[m]?.value || 0;
      return isNaN(val) ? 0 : val;
    });
    try{ return eval(expr); } catch(e){ return '#ERR'; }
  }

  // Recalculate all cells
  function recalcAll(){
    for(const key in cellMap){
      const c = cellMap[key];
      if(c.type==='formula') c.value = evalFormula(c.element.value);
      else if(c.type==='latex') c.value = c.element.value;
    }
    renderLatexCells();
  }

  function renderLatexCells(){
    for(const key in cellMap){
      const c = cellMap[key];
      if(c.type==='latex') texme.render(c.value, c.render);
    }
  }

  // Create a cell
  function createCell(type,col,row){
    const id = cellId(col,row);
    let cellElement, renderEl;
    if(type==='latex'){
      cellElement=document.createElement('textarea'); cellElement.className='input-cell';
      renderEl=document.createElement('div'); renderEl.className='render-cell';
      cellElement.addEventListener('input', ()=>{ cellMap[id].value=cellElement.value; texme.render(cellElement.value, renderEl); recalcAll(); });
      grid.appendChild(cellElement); grid.appendChild(renderEl);
    } else {
      cellElement=document.createElement('textarea'); cellElement.className='input-cell';
      cellElement.addEventListener('input', ()=>{ cellMap[id].value=type==='formula'? evalFormula(cellElement.value) : cellElement.value; recalcAll(); });
      grid.appendChild(cellElement);
    }
    cellMap[id]={type,element:cellElement,value:'',render:renderEl};
  }

  // Add column
  function addColumn(){
    const type = prompt("Column type? latex/text/formula","latex");
    if(!['latex','text','formula'].includes(type)) return;
    columnTypes.push(type);
    const col=numCols;

    // Add header
    const header=document.createElement('div'); header.className='cell header col'; header.textContent=colName(col);
    grid.appendChild(header);

    // Add cells in existing rows
    for(let r=0;r<numRows;r++){ createCell(type,col,r); }

    numCols++;
    grid.style.gridTemplateColumns=`repeat(${numCols},80px)`;
  }

  // Add row
  function addRow(){
    const row=numRows;
    // Row header
    const header=document.createElement('div'); header.className='cell header row'; header.textContent=rowName(row);
    grid.appendChild(header);
    for(let c=0;c<numCols;c++){ createCell(columnTypes[c],c,row); }
    numRows++;
  }

  // Drag selection
  let isDragging=false;
  function startSelection(e){ isDragging=true; e.target.classList.add('selected'); e.preventDefault(); }
  function duringSelection(e){ if(isDragging) e.target.classList.add('selected'); }
  function endSelection(){ isDragging=false; }
  document.addEventListener('mouseup', endSelection);

  // Copy selection
  function copySelection(){
    const selected=Array.from(grid.querySelectorAll('.selected'));
    if(!selected.length) return;
    const text=selected.map(c=>c.value||c.textContent).join('\t');
    const temp=document.createElement('textarea'); document.body.appendChild(temp);
    temp.value=text; temp.select(); document.execCommand('copy'); document.body.removeChild(temp);
    alert('Copied '+selected.length+' cells!');
  }

  // Export CSV
  function exportCSV(){
    let csv='';
    for(let r=0;r<numRows;r++){
      let row=[];
      for(let c=0;c<numCols;c++){
        const id=cellId(c,r);
        const val=cellMap[id]?.value||'';
        row.push('"'+val+'"');
      }
      csv+=row.join(',')+'\n';
    }
    const blob=new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const link=document.createElement('a'); link.href=URL.createObjectURL(blob); link.download='spreadsheet.csv'; link.click();
  }

  // Buttons
  document.getElementById('addRow').onclick=addRow;
  document.getElementById('addCol').onclick=addColumn;
  document.getElementById('copySelection').onclick=copySelection;
  document.getElementById('exportCSV').onclick=exportCSV;

  // Initialize
  addColumn(); addColumn(); addRow();
  grid.style.display='grid'; grid.style.gridTemplateColumns=`repeat(${numCols},80px)`;
}
</script>

</body>
</html>
