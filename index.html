<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spreadsheet-Like LaTeX Editor with Headers</title>
<script src="texme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_HTML"></script>
<style>
  body { font-family: sans-serif; padding: 20px; }
  .container { position: relative; overflow: auto; max-height: 600px; border: 1px solid #ccc; }
  .grid { display: grid; gap: 2px; }
  .cell { border: 1px solid #ccc; padding: 5px; min-height: 50px; overflow-wrap: break-word; box-sizing: border-box; }
  .input-cell { background: #f0f8ff; resize: none; width: 100%; }
  .render-cell { background: #fff; }
  .header { background: #ddd; font-weight: bold; text-align: center; position: sticky; z-index: 2; }
  .header.col { top: 0; }
  .header.row { left: 0; }
  .selected { outline: 2px solid #007bff; }
  button { padding: 6px 10px; margin-right: 5px; cursor: pointer; }
</style>
</head>
<body>

<h2>Spreadsheet-Like LaTeX Editor with Headers</h2>
<div>
  <button id="addRow">Add Row</button>
  <button id="addCol">Add Column</button>
  <button id="copySelection">Copy Selected</button>
  <button id="exportCSV">Export CSV</button>
</div>
<div class="container">
  <div class="grid" id="grid"></div>
</div>

<script>
window.onload = function () {
  const grid = document.getElementById('grid');
  const texmeLine = '<!DOCTYPE html><script src="texme.js"></script><textarea>';
  let timeout = null;
  let numRows = 0;
  let numCols = 2; // initial input columns

  // ----- Utilities -----
  function colName(n) {
    let name = '';
    while (n >= 0) {
      name = String.fromCharCode(65 + (n % 26)) + name;
      n = Math.floor(n/26) -1;
    }
    return name;
  }

  function normalizeInput(input) {
    let code = input.value.replace(/^\s+/, '');
    if (!code.startsWith(texmeLine) && code.length > 0) {
      code = texmeLine + '\n\n' + code;
    }
    input.value = code;
  }

  function renderPreview(input, preview) {
    let code = input.value.replace(texmeLine, '').trim();
    preview.innerHTML = texme.render(code);
    window.MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],
                             ['Typeset', window.MathJax.Hub, preview]);
    autoExpand(input);
  }

  function scheduleInputHandler(input, preview) {
    if (timeout !== null) clearTimeout(timeout);
    timeout = setTimeout(() => { normalizeInput(input); renderPreview(input, preview); }, 100);
  }

  function autoExpand(textarea) {
    textarea.style.height = 'auto';
    textarea.style.height = textarea.scrollHeight + 'px';
  }

  function createCell(type='input', isHeader=false) {
    const cell = type==='input'? document.createElement('textarea') : document.createElement('div');
    cell.className = 'cell';
    if (type==='input') { cell.classList.add('input-cell'); cell.placeholder='Type LaTeX'; cell.addEventListener('input', ()=>autoExpand(cell)); }
    if (type==='render') cell.classList.add('render-cell');
    if (isHeader) { cell.classList.add('header'); cell.textContent=''; }
    return cell;
  }

  function updateGridTemplate() { grid.style.gridTemplateColumns = `50px repeat(${numCols*2}, 1fr)`; }

  // ----- Row and Column Management -----
  function addRow() {
    const rowIndex = numRows+1;
    const rowHeader = createCell('render', true);
    rowHeader.classList.add('row'); rowHeader.textContent = rowIndex;
    grid.appendChild(rowHeader);

    for (let c=0;c<numCols;c++){
      const input = createCell('input');
      const render = createCell('render');
      grid.appendChild(input); grid.appendChild(render);
      hookCell(input, render);
    }
    numRows++;
  }

  function addColumn() {
    const header = createCell('render', true);
    header.classList.add('col'); header.textContent = colName(numCols);
    // Insert column headers before first row
    grid.insertBefore(header, grid.children[numCols*2 + 1]);
    // Add input+render to each existing row
    for (let r=0;r<numRows;r++){
      const input = createCell('input');
      const render = createCell('render');
      const rowStart = r*(numCols*2 +1)+1;
      grid.insertBefore(input, grid.children[rowStart + numCols*2]);
      grid.insertBefore(render, input.nextSibling);
      hookCell(input, render);
    }
    numCols++;
    updateGridTemplate();
  }

  function hookCell(input, render){
    input.onkeyup = () => scheduleInputHandler(input, render);
    input.onpaste = () => scheduleInputHandler(input, render);
    input.oncut = () => scheduleInputHandler(input, render);
    input.addEventListener('keydown', navigateCells);
    input.addEventListener('mousedown', startSelection);
    input.addEventListener('mouseover', duringSelection);
    render.addEventListener('mousedown', startSelection);
    render.addEventListener('mouseover', duringSelection);
  }

  // ----- Navigation -----
  function navigateCells(e){
    const inputs = Array.from(grid.querySelectorAll('.input-cell'));
    const index = inputs.indexOf(e.target);
    let newIndex = null;
    switch(e.key){
      case 'ArrowRight': newIndex=index+1; break;
      case 'ArrowLeft': newIndex=index-1; break;
      case 'ArrowDown': newIndex=index+numCols; break;
      case 'ArrowUp': newIndex=index-numCols; break;
      case 'Tab': e.preventDefault(); newIndex=e.shiftKey?index-1:index+1; break;
    }
    if (newIndex!==null && newIndex>=0 && newIndex<inputs.length) inputs[newIndex].focus();
  }

  // ----- Selection -----
  let isDragging=false;
  function startSelection(e){ isDragging=true; e.target.classList.add('selected'); e.preventDefault(); }
  function duringSelection(e){ if(isDragging) e.target.classList.add('selected'); }
  function endSelection(){ isDragging=false; }
  document.addEventListener('mouseup', endSelection);

  function copySelection(){
    const selected = Array.from(grid.querySelectorAll('.selected'));
    if(!selected.length) return;
    const text = selected.map(c=>c.tagName==='TEXTAREA'?c.value:c.textContent).join('\t');
    const temp=document.createElement('textarea'); document.body.appendChild(temp);
    temp.value=text; temp.select(); document.execCommand('copy'); document.body.removeChild(temp);
    alert('Copied '+selected.length+' cells!');
  }

  function exportCSV(){
    let cols = prompt(`Enter input column indices (0-based) to export:`).split(',').map(c=>parseInt(c.trim())).filter(c=>!isNaN(c));
    if(!cols.length) return alert('No valid columns.');
    const includeRendered = confirm('Include rendered LaTeX?');
    let csv='';
    for(let r=0;r<numRows;r++){
      let row=[];
      cols.forEach(c=>{
        const inputCell = grid.children[r*(numCols*2+1)+1 + c*2];
        row.push('"'+(inputCell.value||'')+'"');
        if(includeRendered){
          const renderCell = grid.children[r*(numCols*2+1)+1 + c*2 +1];
          row.push('"'+(renderCell.textContent||'')+'"');
        }
      });
      csv+=row.join(',')+'\n';
    }
    const blob=new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const link=document.createElement('a'); link.href=URL.createObjectURL(blob);
    link.download='latex_spreadsheet.csv'; link.click();
  }

  document.getElementById('addRow').onclick = addRow;
  document.getElementById('addCol').onclick = addColumn;
  document.getElementById('copySelection').onclick = copySelection;
  document.getElementById('exportCSV').onclick = exportCSV;

  updateGridTemplate();
  // Add initial headers
  for(let i=0;i<numCols;i++){
    const header=createCell('render',true); header.classList.add('col'); header.textContent=colName(i);
    grid.appendChild(header);
  }
  addRow();
}
</script>

</body>
</html>
